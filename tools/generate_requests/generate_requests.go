// Package main generates request types mirroring DynamoDB SDK inputs.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	ddbtypes "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// operations we support via HTTP.
var supportedInputs = []reflect.Type{
	reflect.TypeOf(dynamodb.CreateTableInput{}),
	reflect.TypeOf(dynamodb.DeleteTableInput{}),
	reflect.TypeOf(dynamodb.UpdateTableInput{}),
	reflect.TypeOf(dynamodb.DescribeTableInput{}),
	reflect.TypeOf(dynamodb.PutItemInput{}),
	reflect.TypeOf(dynamodb.DeleteItemInput{}),
	reflect.TypeOf(dynamodb.UpdateItemInput{}),
	reflect.TypeOf(dynamodb.GetItemInput{}),
	reflect.TypeOf(dynamodb.QueryInput{}),
	reflect.TypeOf(dynamodb.ScanInput{}),
	reflect.TypeOf(dynamodb.BatchWriteItemInput{}),
	reflect.TypeOf(dynamodb.BatchGetItemInput{}),
	reflect.TypeOf(dynamodb.TransactWriteItemsInput{}),
}

var attributeValueType = reflect.TypeOf((*ddbtypes.AttributeValue)(nil)).Elem()

type generated struct {
	order []string
	decls map[string]string
}

func main() {
	out := flag.String("out", "server/requests.go", "output file path for generated requests")

	flag.Parse()

	if err := run(*out); err != nil {
		fmt.Fprintf(os.Stderr, "generate failed: %v\n", err)
		os.Exit(1)
	}
}

func run(outPath string) error {
	gen := generated{
		order: []string{},
		decls: map[string]string{},
	}

	for _, t := range supportedInputs {
		generateStruct(&gen, t)
	}

	sort.Strings(gen.order)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by tools/generate_requests; DO NOT EDIT.\n")
	buf.WriteString("package server\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\tddb \"github.com/aws/aws-sdk-go-v2/service/dynamodb\"\n")
	buf.WriteString("\tddbtypes \"github.com/aws/aws-sdk-go-v2/service/dynamodb/types\"\n")
	buf.WriteString(")\n\n")

	for _, name := range gen.order {
		buf.WriteString(gen.decls[name])
		buf.WriteString("\n\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(outPath), 0o750); err != nil {
		return fmt.Errorf("mkdir: %w", err)
	}

	if err := os.WriteFile(outPath, formatted, 0o600); err != nil {
		return fmt.Errorf("write: %w", err)
	}

	return nil
}

func generateStruct(gen *generated, t reflect.Type) { //nolint:gocognit,gocyclo // loops through struct fields only once
	name := t.Name()
	if name == "" {
		return
	}

	if _, ok := gen.decls[name]; ok {
		return
	}

	fields := []string{}

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		// skip smithy internals and unexported.
		if !f.IsExported() || f.Name == "noSmithyDocumentSerde" {
			continue
		}

		fieldType, helperNames := renderType(gen, f.Type)
		for _, hn := range helperNames {
			if _, ok := gen.decls[hn]; !ok {
				// dependency handled in renderType
				_ = hn
			}
		}

		tag := string(f.Tag)

		jsonTag := fmt.Sprintf("`json:\"%s,omitempty\"`", f.Name)
		if tag == "" {
			tag = jsonTag
		} else if !strings.Contains(tag, "json:\"") {
			tag = strings.TrimSpace(tag + " " + jsonTag)
		}

		fields = append(fields, fmt.Sprintf("\t%s %s %s", f.Name, fieldType, tag))
	}

	var b bytes.Buffer
	fmt.Fprintf(&b, "type %s struct {\n", name)

	for _, f := range fields {
		b.WriteString(f)
		b.WriteString("\n")
	}

	b.WriteString("}\n")

	gen.order = append(gen.order, name)
	gen.decls[name] = b.String()
}

func renderType(gen *generated, t reflect.Type) (string, []string) { //nolint:gocognit,gocyclo // switch enumerates all type cases
	if t == attributeValueType {
		return "*AttributeValue", nil
	}

	// handle named types from dynamodb packages (including enums) early.
	if t.PkgPath() == "github.com/aws/aws-sdk-go-v2/service/dynamodb/types" {
		if t.Kind() == reflect.Struct && needsGeneration(t) {
			generateStruct(gen, t)
			return t.Name(), []string{t.Name()}
		}

		return "ddbtypes." + t.Name(), nil
	}

	if t.PkgPath() == "github.com/aws/aws-sdk-go-v2/service/dynamodb" {
		if t.Kind() == reflect.Struct && needsGeneration(t) {
			generateStruct(gen, t)
			return t.Name(), []string{t.Name()}
		}

		return "ddb." + t.Name(), nil
	}

	switch t.Kind() {
	case reflect.Pointer:
		inner, helpers := renderType(gen, t.Elem())
		return "*" + inner, helpers
	case reflect.Slice:
		inner, helpers := renderType(gen, t.Elem())
		return "[]" + inner, helpers
	case reflect.Map:
		key, hk := renderType(gen, t.Key())
		val, hv := renderType(gen, t.Elem())

		helpers := append([]string{}, hk...)
		helpers = append(helpers, hv...)

		return fmt.Sprintf("map[%s]%s", key, val), helpers
	case reflect.Interface:
		// Replace AttributeValue interfaces with our concrete struct.
		if t == attributeValueType {
			return "*AttributeValue", nil
		}

		return t.String(), nil
	case reflect.Struct:
		if t.PkgPath() == "github.com/aws/aws-sdk-go-v2/service/dynamodb" || t.PkgPath() == "github.com/aws/aws-sdk-go-v2/service/dynamodb/types" {
			if t == reflect.TypeOf(ddbtypes.AttributeValueMemberNULL{}) {
				return "ddbtypes.AttributeValueMemberNULL", nil
			}

			if needsGeneration(t) {
				generateStruct(gen, t)
				return t.Name(), []string{t.Name()}
			}

			// use fully-qualified name for pass-through structs
			pkgAlias := "ddb"
			if t.PkgPath() == "github.com/aws/aws-sdk-go-v2/service/dynamodb/types" {
				pkgAlias = "ddbtypes"
			}

			return pkgAlias + "." + t.Name(), nil
		}

		return t.String(), nil
	default:
		return t.String(), nil
	}
}

func needsGeneration(t reflect.Type) bool {
	if t.Kind() != reflect.Struct {
		return false
	}

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		if !f.IsExported() {
			continue
		}

		if containsAttributeValue(f.Type) {
			return true
		}
	}

	return false
}

func containsAttributeValue(t reflect.Type) bool {
	switch t.Kind() {
	case reflect.Pointer, reflect.Slice, reflect.Map:
		return containsAttributeValue(t.Elem())
	case reflect.Interface:
		return t == attributeValueType
	case reflect.Struct:
		for i := 0; i < t.NumField(); i++ {
			if containsAttributeValue(t.Field(i).Type) {
				return true
			}
		}
	}

	return false
}
